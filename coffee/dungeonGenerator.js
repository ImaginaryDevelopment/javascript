// Generated by CoffeeScript 1.4.0
/*
based on 
http://roguebasin.roguelikedevelopment.org/index.php?title=Java_Example_of_Dungeon-Building_Algorithm
*/

var Direction, Dungeon, Feature, PointI, Tile, Tiles, getTile, imgBase, makeImg;

Math.randInt = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

if (!Array.prototype.some) {
  Array.prototype.some = function(f) {
    var x;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    }).call(this)).length > 0;
  };
}

if (!Array.prototype.every) {
  Array.prototype.every = function(f) {
    var x;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    }).call(this)).length === this.length;
  };
}

if (!Array.prototype.cross) {
  Array.prototype.cross = function(A) {
    var results, x, y, _i, _j, _len, _len1;
    results = [];
    for (_i = 0, _len = A.length; _i < _len; _i++) {
      x = A[_i];
      for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
        y = this[_j];
        results.push({
          x: x,
          y: y
        });
      }
    }
    return results.flatten();
  };
}

Direction = {
  North: 0,
  East: 1,
  South: 2,
  West: 3
};

Tile = (function() {

  function Tile(name, compatChar, src, color, passable) {
    this.name = name;
    this.compatChar = compatChar;
    this.src = src;
    this.color = color;
    this.passable = passable;
  }

  return Tile;

})();

Tile.prototype.isDirtfloorOrCorridor = function() {
  return this.name === "dirtFloor" || this.name === "corridor";
};

imgBase = "http://imaginarydevelopment.com/assets/planetcute png/";

makeImg = function(base, suffix) {
  return "<img src=\"" + base + suffix + "\" />";
};

Tiles = [new Tile("unused", "_", " ", "black", true), new Tile("dirtWall", "+", makeImg(imgBase, "Dirt Block.png"), "brown", false), new Tile("dirtFloor", ".", makeImg(imgBase, "Brown Block.png"), "brown", true), new Tile("stoneWall", "O", makeImg(imgBase, "Rock.png"), "grey", false), new Tile("corridor", "#", makeImg(imgBase, "Stone Block.png"), "brown", true), new Tile("door", "D", makeImg(imgBase, "Wood Block.png"), "brown", true), new Tile("upStairs", "<", makeImg(imgBase, "Ramp West.png"), "#CC6633", true), new Tile("downStairs", ">", makeImg(imgBase, "Ramp East.png"), "#CC6633", true)];

getTile = function(name) {
  var matches;
  matches = Tiles.filter(function(t) {
    return t.name === name;
  });
  if (matches.length > 0) {
    return matches[0];
  }
};

Feature = (function() {

  function Feature(name, x, y, yEnd, xEnd) {
    this.name = name;
    this.x = x;
    this.y = y;
    this.yEnd = yEnd;
    this.xEnd = xEnd;
  }

  return Feature;

})();

PointI = (function() {

  function PointI(x, y) {
    this.x = x;
    this.y = y;
  }

  return PointI;

})();

Dungeon = function(irandomizer) {
  this.xmax;
  this.ymax;
  this.rnd = irandomizer;
  this.xsize = 0;
  this.ysize = 0;
  this.objects;
  this.chanceRoom = 75;
  this.dungeonFeatures = [];
  this.dungeonMap = [];
  this.msgXSize = "X size of dungeon: \t";
  this.msgYSize = "Y size of dungeon: \t";
  this.msgMaxObject = "Max objects: \t";
  this.msgNumObjects = "Created objects: \t";
  return this;
};

Dungeon.prototype.initialize = function(x, y) {
  var buildWall;
  this.xsize = x;
  this.ysize = y;
  console.log(this.msgXSize + this.xsize);
  console.log(this.msgYSize + this.ysize);
  this.dungeonMap = [];
  this.dungeonFeatures = [];
  y = 0;
  while (y < this.ysize) {
    x = 0;
    while (x < this.xsize) {
      buildWall = y === 0 || y === this.ysize - 1 || x === 0 || x === this.xsize - 1;
      this.setCell(x, y, getTile(buildWall ? "stoneWall" : "unused"));
      x++;
    }
    y++;
  }
  return true;
};

Dungeon.prototype.setCell = function(x, y, cellType) {
  return this.dungeonMap[x + this.xsize * y] = cellType;
};

Dungeon.prototype.getCellType = function(x, y) {
  return this.dungeonMap[x + this.xsize * y];
};

Dungeon.prototype.inBounds = function(x, y) {
  return x >= 0 && x < this.xmax && y >= 0 && y <= this.ymax;
};

Dungeon.prototype.getCorridorPoints = function(x, y, len, direction) {
  var _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results, _results1, _results2, _results3;
  switch (d) {
    case Direction.North:
      return (function() {
        _results = [];
        for (var _i = _ref = y - len; _ref <= y ? _i <= y : _i >= y; _ref <= y ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(m) {
        return [x, m];
      });
    case Direction.East:
      return (function() {
        _results1 = [];
        for (var _j = x, _ref1 = x + len; x <= _ref1 ? _j <= _ref1 : _j >= _ref1; x <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(m)(function() {
        return [m, y];
      });
    case Direction.South:
      return (function() {
        _results2 = [];
        for (var _k = y, _ref2 = y + len; y <= _ref2 ? _k <= _ref2 : _k >= _ref2; y <= _ref2 ? _k++ : _k--){ _results2.push(_k); }
        return _results2;
      }).apply(this).map(m)(function() {
        return [x, m];
      });
    case Direction.West:
      return (function() {
        _results3 = [];
        for (var _l = _ref3 = x - xlen; _ref3 <= x ? _l <= x : _l >= x; _ref3 <= x ? _l++ : _l--){ _results3.push(_l); }
        return _results3;
      }).apply(this).map(m)(function() {
        return [m, y];
      });
  }
};

Dungeon.prototype.makeCorridor = function(x, y, length, direction) {
  var len, points, self;
  if (x < 0 || x > this.xsize) {
    return false;
  }
  self = this;
  len = Math.randInt(2, length);
  points = this.getCorridorPoints(x, y, len, direction);
  if (points.some(function(p) {
    return !this.inBounds(p) || this.getCellType(p.X, p.Y) !== "unused";
  })) {
    return false;
  }
  (function(i) {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      i = points[_i];
      _results.push(this.setCell(i.X, i.Y, "corridor"));
    }
    return _results;
  });
  return true;
};

Dungeon.prototype.getFeatureLowerBound = function(c, len) {
  return Math.round(c - len / 2);
};

Dungeon.prototype.getFeatureUpperBound = function(c, len) {
  return Math.round(c + (len + 1) / 2);
};

Dungeon.prototype.getRoomPoints = function(x, y, xlen, ylen, d) {
  var a, b, _i, _j, _ref, _ref1, _ref2, _results, _results1;
  a = this.getFeatureLowerBound;
  b = this.getFeatureUpperBound;
  switch (d) {
    case Direction.North:
      return (function() {
        _results1 = [];
        for (var _j = _ref1 = a(x, xlen), _ref2 = b(x, xlen); _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; _ref1 <= _ref2 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).cross((function() {
        _results = [];
        for (var _i = y, _ref = y - ylen; y <= _ref ? _i < _ref : _i > _ref; y <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this)).flatten();
    case Direction.East:
      return [];
    case Direction.South:
      return [];
    case Direction.West:
      return [];
  }
};

Dungeon.prototype.makeRoom = function(x, y, xlength, ylength, direction) {
  var floor, points, self, wall, xlen, ylen;
  self = this;
  console.log("attempting to make room:" + x + "," + y);
  xlen = Math.randInt(4, xlength);
  ylen = Math.randInt(4, ylength);
  floor = getTile("dirtFloor");
  wall = getTile("dirtWall");
  points = this.getRoomPoints(x, y, xlen, ylen, direction);
  if (points.some(function(p) {
    return p.x < 0 || p.y > this.ysize || p.x < 0 || p.y > this.xsize || self.getCellType(p.x, p.y) !== "unused";
  })) {
    return false;
  }
  return true;
};

Dungeon.prototype.getDungeon = function() {
  return this.dungeonMap.slice(0);
};

Dungeon.prototype.showDungeon = function() {
  var row, x, y, _results;
  y = 0;
  _results = [];
  while (y < this.ysize) {
    x = 0;
    row = '';
    while (x < this.xsize) {
      row += this.getCellType(x, y).src;
      x++;
    }
    console.log(row + " " + y);
    _results.push(y++);
  }
  return _results;
};

Dungeon.prototype.findvalidTile = function() {
  validTile;

  var cell1, cell2, cell3, cell4, cellType, newx, newy, testing, validTile;
  testing = 0;
  while (testing <= 1000) {
    testing++;
    newx = Math.randInt(1, this.xsize - 1);
    newy = Math.randInt(1, this.ysize - 1);
    validTile = void 0;
    cellType = this.getCellType(newx, newy);
    if (cellType.name === "dirtWall" || cellType.name === "corridor") {
      cell1 = this.getCellType(newx, newy + 1);
      cell2 = this.getCellType(newx - 1, newy);
      cell3 = this.getCellType(newx, newy - 1);
      cell4 = this.getCellType(newx + 1, newy);
      if (cell1 && cell1.isDirtfloorOrCorridor()) {
        validTile = {
          validTile: 0,
          newx: newx,
          newy: newy,
          xmod: 0,
          ymod: -1
        };
      } else if (cell2 && cell2.isDirtfloorOrCorridor()) {
        validTile = {
          validTile: 1,
          newx: newx,
          newy: newy,
          xmod: +1,
          ymod: 0
        };
      } else if (cell3 && cell3.isDirtfloorOrCorridor()) {
        validTile = {
          validTile: 2,
          newx: newx,
          newy: newy,
          xmod: 0,
          ymod: +1
        };
      } else if (cell4 && cell4.isDirtfloorOrCorridor()) {
        validTile = {
          validTile: 3,
          newx: newx,
          newy: newy,
          xmod: -1,
          ymod: 0
        };
      }
      if (validTile > (-1)) {
        if ((cell1 && cell1.name === "door") || (cell2 && cell2.name === "door") || (cell3 && cell3.name === "door") || (cell4 && cell4.name === "door")) {
          console.log('invalidating tile for door');
          validTile = void 0;
        }
      }
      if (validTile >= 0) {
        break;
      }
    }
  }
  return validTile;
};

Dungeon.prototype.createDungeon = function(inx, iny, inobj) {
  var countingTries, currentFeatures, feature, madeStart, validTile, xcenter, ycenter;
  this.objects = inobj < 1 ? 10 : inobj;
  if (inx < 3) {
    this.xsize = 3;
  } else if (iny > this.ymax) {
    this.ysize = this.ymax;
  } else {
    this.xsize = inx;
  }
  if (iny < 3) {
    this.ysize = this.ymax;
  } else if (iny > this.ymax) {
    this.ysize = this.ymax;
  } else {
    this.ysize = iny;
  }
  this.initialize(this.xsize, this.ysize);
  console.log(this.msgMaxObject + this.objects);
  xcenter = Math.round(this.xsize / 2);
  ycenter = Math.round(this.ysize / 2);
  console.log('making start room');
  madeStart = this.makeRoom(xcenter, ycenter, 8, 6, Math.randInt(0, 3));
  if (madeStart === false) {
    throw "couldn't make start room";
  }
  this.showDungeon;
  currentFeatures = 1;
  countingTries = 0;
  while (countingTries <= 1000) {
    countingTries++;
    if (currentFeatures >= this.objects) {
      break;
    }
    validTile = this.findvalidTile();
    if (validTile && validTile.validTile >= 0) {
      console.log('making a feature!');
      feature = Math.randInt(0, 100);
      if (feature <= this.chanceRoom) {
        console.log('making a room at ' + JSON.stringify(validTile));
        if (this.makeRoom(validTile.newx + validTile.xmod, validTile.newy + validTile.ymod, 8, 6, validTile.validTile)) {
          console.log('made a room!');
          currentFeatures++;
          this.setCell(validTile.newx, validTile.newy, getTile("door"));
          this.setCell(validTile.newx + validTile.xmod, validTile.newy + validTile.ymod, getTile("dirtFloor"));
        }
      } else if (feature >= this.chanceRoom) {
        console.log('making a corridor!');
        if (this.makeCorridor(validTile.newx + validTile.xmod, validTile.newy + validTile.ymod, 6, validTile.validTile)) {
          console.log('made a corridor!');
          currentFeatures++;
          this.setCell(validTile.newx, validTile.newy, getTile("door"));
        }
      }
    }
  }
  console.log("countingTries:" + countingTries);
  this.addSprinkles();
  console.log(this.msgNumObjects + currentFeatures);
  return true;
};

Dungeon.prototype.addSprinkles = function() {
  var cantgo, newx, newy, self, state, testing, ways, _results;
  newx = 0;
  newy = 0;
  ways = 0;
  state = 0;
  _results = [];
  while (state !== 10) {
    testing = 0;
    _results.push((function() {
      var _results1;
      _results1 = [];
      while (testing < 1000) {
        newx = Math.randInt(1, this.xsize - 2);
        newy = Math.randInt(1, this.ysize - 2);
        ways = 4;
        self = this;
        cantgo = function(x, y) {
          return self.getCellType(x, y).isDirtfloorOrCorridor() || self.getCellType(x, y).name !== "door";
        };
        if (cantgo(newx, newy + 1)) {
          ways--;
        }
        if (cantgo(newx - 1, newy)) {
          ways--;
        }
        if (cantgo(newx, newy - 1)) {
          ways--;
        }
        if (cantgo(newx + 1, newy)) {
          ways--;
        }
        if (state === 0 && ways === 0) {
          this.dungeonFeatures.push(new Feature("upStairs", newx, newy, newx, newy));
          state = 1;
          this.setCell(newx, newy, getTile("upStairs"));
          break;
        }
        if (state === 1 && ways === 0) {
          this.setCell(newx, newy, getTile("downStairs"));
          this.dungeonFeatures.push(new Feature("downStairs", newx, newy, newx, newy));
          state = 10;
          break;
        }
        _results1.push(testing++);
      }
      return _results1;
    }).call(this));
  }
  return _results;
};
